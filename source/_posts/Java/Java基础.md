---
title: Java基础
tags: Java
---
## 重载与重写

重载发生在**同一个类中**（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

重写就是**子类对父类方法的重新改造**，外部样子不能改变，内部逻辑可以改变。**重写发生在运行期**，是子类对父类的允许访问的方法的实现过程进行重新编写。

- 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
- 如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
- 构造方法无法被重写

方法的重写要遵循“**两同两小一大**”：

- “两同”即方法名相同、形参列表相同；
- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

## == 和 equals() 的区别

`==`对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，== 比较的是值。
- 对于引用数据类型来说，== 比较的是对象的内存地址。

`equals()`存在两种使用情况：

- 类没有覆盖 `equals()`方法 ：通过 `equals()`比较该类的两个对象时，等价于通过 `==`比较这两个对象，使用的默认是 Object 类 equals()方法。
- 类覆盖了 equals()方法 ：一般我们都覆盖 equals()方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

## hashCode() 与 equals()

hashCode() 和 equals()都是用于比较两个对象是否相等。有了 hashCode() 之后，判断元素是否在对应容器中的效率会更高。如 HashSet 在对比的时候，同样的 hashCode 有多个对象，它会继续使用 equals() 来判断是否真的相同。也就是说 hashCode 帮助我们大大缩小了查找成本。

- 如果两个对象的 hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的 hashCode 值相等并且 equals()方法返回 true，我们才认为这两个对象相等。
- 如果两个对象的 hashCode 值不相等，我们就可以直接认为这两个对象不相等。

## 8 种基本数据类型

- 4 种整数型：byte（1），short（2），int（4），long（8）
- 2 种浮点类型：float（4），double（8）
- 1 种字符型：char（2）
- 1 种布尔类型：boolean

## 包装类型的常量池技术

Byte, Short, Integer, Long 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，Character 创建了数值在 [0,127] 范围的缓存数据，Boolean 直接返回 True or False。两种浮点数类型的包装类 Float, Double 并没有实现常量池技术。

```
Integer i1 = 40; //发生装箱，直接使用的是常量池种的对象
Integer i2 = new Integer(40); //会直接创建新的对象
System.out.println(i1==i2); //返回false
```

所有整型包装类对象之间值的比较，应全部使用 equals 方法比较。

## 自动装箱与拆箱

- 装箱：将基本类型用它们对应的引用类型包装起来；
- 拆箱：将包装类型转换为基本数据类型；

Java 是一种完全面向对象的语言。因此，包括数字、字符、布尔值等等在内的一切，都是对象。似乎只需要一种方式来对待这些对象就可以了。
对于计算机来说，处理一个完整的对象，需要更多的指令与内存。如果连整数都是对象，那么性能自然很低。
于是创造了这样一种机制，使得这些基本类型在一般的编程中被当作非对象的简单类型处理，在另一些场合，又允许它们被视作是一个对象。
**作用：为了保证通用性和提高系统性能，设置了装箱与拆箱机制**

装箱其实就是调用了 包装类的 valueOf()方法，拆箱其实就是调用了 xxxValue()方法。

```
Integer i = 10 等价于 Integer i = Integer.valueOf(10) //装箱
int n = i 等价于 int n = i.intValue(); //拆箱
```

`<font color='red'>`注：如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。`</font>`

## 面向对象与面向过程

- 面向对象：面向对象就是构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。
  特点：易维护、易复用、可以设计出低耦合的系统，使系统更加灵活、更加易于维护。性能低。
- 面向过程不同于面向对象，面向过程分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了
  特点：性能高，可应用于如单片机、嵌入式开发中。

## 对象相等与引用相等

- 对象相等一般比较的是内存中存放的内容是否相等。
- 引用相等一般指的是引用所指向的内存地址是否相等。

## 面向对象三大特征

- **封装：** 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法（get/set）来操作属性。
  - 良好的封装可以减少耦合;
  - 类内部可以自由修改；
  - 对成员进行更精准的控制；
  - 隐藏实现细节。
- **继承：** 继承使用已存在的类的定义作为基础建立新类，使用继承我们能够非常方便地复用以前的代码，提高开发效率。
  - 子类可以拥有父类所有属性与方法，但是父类对象中的私有属性和方法，子类是无法访问到的；
  - 子类可以对父类进行扩展（子类拥有自己的属性和代码）；
  - 子类可以用自己的方式实现父类的方法。
- **多态：** 一个引用变量倒底会指向哪个类的实例对象，在程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。
  - 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
  - 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；
  - 多态不能调用“只在子类存在但在父类不存在”的方法；
  - 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。

## 深拷贝/浅拷贝/引用拷贝

- **浅拷贝：** 浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝：** 深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
  **引用拷贝：** 二者的引用是同一个对象，并没有创建出一个新的对象。因为是同一个对象的引用，所以两者改一个，另一个对象的值也随之改变。即：两个不同的引用指向同一个对象。
  ![三种拷贝方式](https://javaguide.cn/assets/img/shallow&deep-copy.324f14fe.png)

## String/StringBuffer/StringBuilder

String 类中使用 final 关键字修饰字符数组来保存字符串。String 对象是不可变的。

```
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
    private final char value[];
	  //...
}
```

StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰，最关键的是这个 AbstractStringBuilder 类还提供了很多修改字符串的方法比如 append 方法。

- 线程安全性
  - String 对象是不可变的，理解为常量，线程安全。
  - StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。
  - StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。
- 性能
  - 每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。
  - StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升

总结：少量操作用 String，单线程大量数据用 StringBuilder，多线程大数据量用 StringBuffer。
注意：字符串拼接时，使用 `+`或 `+=`实际上是通过 StringBuilder 调用 append() 方法实现的。在循环内使用，每次循环会创建一个实际上是通过 StringBuilder 对象。直接使用 StringBuilder 进行字符串拼接则不会出现重复创建对象的问题。

## 字符串常量池

字符串常量池是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

```
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa==bb);// true
```

## 泛型

泛型的本质是将类型进行参数化，也就是说所操作的数据类型被指定为一个参数。
Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说**类型擦除**。
三种使用方式：泛型类，泛型接口，泛型方法。
常用通配符：
  `T`：具体的Java类型
  `E`：Element，泛型方法
  `K/V`：Java中的键值对
  `?`：不确定的Java类型

## 反射

赋予了我们在运行时分析类以及执行类中方法的能力，通过反射可以获取任意一个类的所有属性和方法。在框架中使用的比较多，**框架中大量使用了动态代理，而动态代理的实现依赖反射。**
优点：让代码更灵活，使各种框架开箱即用，为开发者提供便利。
缺点：
  反射的型能稍微差一点；
  安全问题，使用反射技术要求程序必须在一个没有安全限制的环境中运行。
  反射允许代码执行一些在正常情况下不被允许的操作(比如访问私有的属性和方法)，导致意料之外的副作用。
获取Class对象的四种方式：

* 知道具体类的情况下可以使用:
  `Class alunbarClass = TargetObject.class;`
* 通过 Class.forName()传入类的路径获取：
  `Class alunbarClass1 = Class.forName("cn.javaguide.TargetObject");`
* 通过对象实例instance.getClass()获取：
  ```
    TargetObject o = new TargetObject();
    Class alunbarClass2 = o.getClass();
  ```
* 通过类加载器xxxClassLoader.loadClass()传入类路径获取:
  `Class clazz = ClassLoader.loadClass("cn.javaguide.TargetObject");`

## 注解

可以看作是一种特殊的注释，主要用于修饰类、方法或者变量。
注解本质是一个继承了Annotation 的特殊接口。
注解只有被**解析之后才会生效**，常见的解析方法有两种：

* 编译期直接扫描 ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。
* 运行期通过反射处理 ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。

## 异常

Java异常共同的祖先是 `Throwable`类，有两个重要子类:

* `Exception `：程序可处理的异常，又可分为受检查异常和不受检查异常。
  * 受检查异常：代码在编译过程中，如果受检查异常没有被 catch/throw 处理的话，就没办法通过编译 。**除了RuntimeException及其子类**以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IOException、FileNotFoundException、SQLException...
  * 不受检查异常：**RuntimeException及其子类**都统称为非受检查异常。常见的有：NullPointerException、NumberFormatException、ArrayIndexOutOfBoundsException等。
* `Error`：属于程序无法处理的错误，发生时通常使得线程终止。
  `<font color='red'>`注意：finally块中一般不使用return。当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句不会被执行。`</font>`

## I/O

对于不想进行序列化的变量，使用 `transient`关键字修饰。

* 有了字节流，为什么还要有字符流?
  字符流是通过字节流转换的到的，这个过程会耗费时间，同时如果不知道编码类型可能出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。

## Java为什么只有值传递

* 值传递：方法接收的是实参值的拷贝，会创建副本。
* 引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。

Java 中将实参传递给方法（或函数）的方式是值传递 ：

* 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
* 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。


## 接口和抽象类的区别
* 相同点：
  1. 都不能被实例化
  2. 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。
* 不同点
  1. 接口只有定义，不能有方法的实现。而抽象类可以有定义与实现，方法可在抽象类中实现。
  2. 实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。
  3. 接口强调特定功能的实现，而抽象类强调所属关系。
  4. 接口成员变量默认为public static final，必须赋初值，不能被修改；其所有的成员方法都是public、abstract的。抽象类中成员变量默认default，可在子类中被重新定义，也可被重新赋值；抽象方法被abstract修饰，不能被private、static、synchronized和native等修饰，必须以分号结尾，不带花括号。